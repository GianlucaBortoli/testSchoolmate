\documentclass{sig-alternate-05-2015}
\usepackage{subscript}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[lined,boxed,longend,ruled]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\SetKwProg{Fn}{def}{\string:}{end}
\SetKwFunction{CompGrid}{compute\_grid}
\SetKwFunction{CompTop}{compute\_topics}
\SetKwFunction{CompComArea}{compute\_intersection}
\SetKwFunction{CompDiffArea}{compute\_difference}
\SetKwFunction{CrDT}{create\_dataframes}
\SetKwFunction{SeqCom}{sequential\_computation}
\SetStartEndCondition{ }{}{}%
\SetKw{KwTo}{in}\SetKwFor{For}{for}{\string:}{end for}%
\newcommand{\forcond}{$df$ \KwTo{$dist\_clust\_pages$}}
\newcommand{\forRecDiff}{$map$ \KwTo{$commonAreas$}}
\newcommand{\forRecCom}{$map$ \KwTo{$computedMaps$}}
\newcommand{\forNaive}{$page$ \KwTo{$pages$}}
\newcommand{\forNaiveCom}{$cell$ \KwTo{$squares$}}
\newcommand\lword[1]{\leavevmode\nobreak\hskip0pt plus\linewidth\penalty50\hskip0pt plus-\linewidth\nobreak#1}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%
\graphicspath{ {./imgs/} }

% listings PHP code color
\definecolor{dkgreen}{rgb}{0,.6,0}
\definecolor{dkblue}{rgb}{0,0,.6}
\definecolor{dkyellow}{cmyk}{0,0,.8,.3}
\lstset{
  language        = php,
  basicstyle      = \small\ttfamily,
  keywordstyle    = \color{dkblue},
  stringstyle     = \color{red},
  identifierstyle = \color{dkgreen},
  commentstyle    = \color{gray},
  emph            =[1]{php},
  emphstyle       =[1]\color{black},
  emph            =[2]{if,and,or,else},
  emphstyle       =[2]\color{dkyellow}
}


\begin{document}

\title{Security testing report}

\numberofauthors{1}
\author{
    Gianluca Bortoli\\
           \affaddr{DISI\,-\,University of Trento}\\
           \affaddr{Student id: 179816}\\
           \email{gianluca.bortoli@studenti.unitn.it}
}
\maketitle


\section{Introduction}
This work aims at performing a security analysis study on \emph{Schoolmate}.
This web service is PHP/MySQL solution for elementary,
middle and high schools where different type of users can manage all the needed
information to fulfill their job.

This report is structured as follows. Section \ref{tests} describes the naming
convention used for the test cases and how they are structured into packages.
Section \ref{fixes} describes the vulnerabilities that have been found on the
application, their root causes and how to fix them. Section \ref{outcomes} reports
the results of the proof-of-concept (PoC) attacks described in Section \ref{tests}.
Finally, Section \ref{steps} depicts the steps that have to be taken in order to
be able to run all the tests from scratch, while Section \ref{conclusions} gives
a general evaluation of the whole work.


\section{Security test cases}\label{tests}
Pixy is a scanner static code analysis tools that scans PHP applications for
security vulnerabilities. This software is used in order to spot the possible
vulnerabilities in \emph{Schoolmate}, the subject web application.

The workflow followed developing this work is the following:
\begin{enumerate}
    \item run Pixy on the application code to produce vulnerability reports
        regarding Cross Site Scripting attacks (XSS).
    \item \label{classification} manually analyze all the reports to classify the vulnerabilities.
        Thus, each of them has to be categorized as \textbf{false positive},
        \textbf{reflected XSS} or \textbf{stored XSS} (see \emph{xss\_classification.pdf}
        attachment).
    \item write all the test cases for all the true positives (TP) found (ie. the
        vulnerabilities classified either as reflected or stored XSS) in the form
        of a PoC attack against the application under test.
    \item check that every test case fails on the bugged application to demonstrate
        \emph{Schoolmate} has such security vulnerabilities.
    \item \label{fix} modify the \emph{Schoolmate}'s PHP code to fix the vulnerabilities found
        in step \ref{classification}.
    \item run again the test suite and check all the tests pass, meaning that
        the PoC attack implemented in each test case is no longer possible.
    \item run again Pixy on the fixed application source code to check the
        vulnerabilities are really fixed and making sure step \ref{fix} did not
        introduce any security breach.
\end{enumerate}
The test suite developed to demonstrate that the application under revision has
security concerns makes use of JWebUnit, a Java-based testing framework for web
applications. Every Pixy report is identified by a number and may contain multiple
vulnerabilities. The test suite's source code is structured as follows:
\begin{itemize}
    \item the \textbf{src/main/java} folder contains a Java file for each Pixy report which
        has at least one TP. The test-case Java file naming follows the convention
        \lword{\emph{Test<PixyReportNumber>.java}} so that it is possible to easily match the test
        case with its Pixy report counterpart.
    \item the \textbf{src/main/java/common} folder contains three packages that implement
        utility functions that are available to all the test cases. These functions
        allows not to soil the actual test case implementation, separating all the
        sequences of operations that has to be done in many tests in order to navigate
        the web page depending on the situation.
\end{itemize}
A noteworthy aspect is how tests' assertions are written. When dealing with
security PoC test cases, the security expert writes a test that is thought to fail
if the vulnerability can be exploited and pass otherwise. Hence, in this scenario
a failing test (and its assertion) means that the vulnerability is still present,
while a passing one means that the vulnerability is not present any more.
For the seek of generality all the test cases can run in any order. To achieve this,
every test cases involving a stored XSS vulnerability has a $cleanup$ function called
after the test case execution which removes potentially dirty data from the database.

Furthermore, most of the tests perform three types of action on the web page.
They can \emph{navigate} through the pages of the web application clicking buttons and links,
they can \emph{input} some values in the available forms and text fields and finally they
\emph{make assertions} about the content of the page (eg. that a malicious link is not
present in the page).

Last but not least, some of the test cases (ie. the ones involving the variable $page2$)
required to modify the structure of the Document Object Model (DOM) of the webpage, since
the submit buttons of the forms automatically set values for some of the form's hidden
fields using some javascript code connected to the \emph{onClick} action.
To overcome this issue, a new ad-hoc submit button is created inside the form
and this one is used to perform the action instead of the original one. This functionality
is implemented inside the \lword{\emph{src/common/utils.java}} file in the \emph{addSubmitButton}
function.


\section{Source code fixes}\label{fixes}
All the vulnerabilities explained in Section~\ref{tests} are exploited in the test cases
by means of inserting a malicious link that appears on the page. This succeeds because
the application does not perform any kind of validation and/or sanitization on the variables
that are shown on the page. Unfortunately, many of these variables are (or contained) input
under the control of the user. Thus, performing sanitization steps is not an option in this
case.

The sanitization phase can be performed either before the user input is stored in the
MySQL database or when the value is retrieved from the storage to be displayed on the
web page. This is up to the developer and highly depends on the application structure.
To fix the PHP source code of \emph{Schoolmate}, this work makes use of the first approach.
Recalling that the \emph{index.php} file is the one handling every request coming from
every other page in the application and is the one including all the other ones depending
on the values of $page$ and $page2$.

This architectural decision can be exploited in order
to fix all the vulnerabilities affecting the entire application in a single page.
The portion code shown below is the one responsible for the sanitization step
of all the POST parameters reaching the application.

\begin{lstlisting}[frame=single, caption={Fixing all the vulnerabilities in index.php}]
<?php
foreach ($_POST as $k => $val) {
 $_POST[$k] =
    htmlentities($val, ENT_QUOTES, "UTF-8");
}
...
?>
\end{lstlisting}

The decision to apply the \textbf{htmlentities} function to all the items in the POST array allows
to eliminate the possibility to modify the page's DOM by means of malicious tags in the input
text fields that are later printed on the page. This function converts all the characters
that has a special meaning in HTML to its ``safe'' encoded version. The optional parameter
\emph{ENT\_QUOTES} is used to convert both double and single quotes, while the \emph{UTF-8}
specities the encoding to be used when converting the characters.
Finally, the addition of this code snippet as the first lines of the $index.php$ file allows to
fix both the stored and the reflected XSS vulnerabilities in $Schoolmate$, since only the XSS
vulnerabilities are of interest for this work.


\section{Conclusions}\label{outcomes}
The test cases developed for this work and explained in Section~\ref{tests} covers all the
Pixy vulnerabilities classified as true positives. All the tests failed when the original code
of $Schoolmate$ is used to run the application, while they all successfully pass after the
fixes explained in Section~\ref{fixes}.

In order to check if the fixed code does not introduce any new vulnerability and does not contain
any vulnerability at all, the Pixy static analyzer is run again on $Schoolmate$.
After this final step, Pixy revealed the same vulnerabilities as if the code is still vulnerable.
All the PoC tests successfully pass after patching the application, but it is possible to claim that
all the reports created by Pixy are false positives. This is be due to the fact that static anaysis
tools perform an overestimation of the paths that can be followed during an actual execution
of the application\footnote{As explained in Section~\ref{tests}, this is the reason why an initial
dinstinction between TP and FP has to be done in advance before implementing the PoC attacks.}.
Thus, based on the outcome of the test suite, it is possible to say that the vulnerabilities are
fixed.


\section{Preliminary steps}\label{steps}
Some preliminary steps has to be followed in order to run all the test cases:
\begin{enumerate}
    \item install and run a webserver (eg. Apache), PHP and MySQL.
    \item edit the $\$dbuser$ and $\$dbpass$ values in the $index.php$ file in order
        to match the ones of the MySQL instance to be used.
    \item copy the $Schoolmate$ source files inside the webserver directory.
    \item import the $dbDump.sql$ script in the MySQL instance. It takes care of creating
        the a database with the right name and populating it with some initial values.
        All the queries on the database should succeed.
\end{enumerate}
After all the abovementioned steps are completed successfully, $Schoolmate$ is up and running
and the test suite can be run.


%\end{document}  % This is where a 'short' article might terminate
%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.

%\bibliographystyle{abbrv}
%\bibliography{biblio}% biblio.bib is the name of the Bibliography in this case

% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%

\end{document}
